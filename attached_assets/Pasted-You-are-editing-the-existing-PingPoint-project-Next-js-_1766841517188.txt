You are editing the existing PingPoint project (Next.js + Express backend) on Replit.
Goal: extend the existing Admin Panel so that an authenticated admin can manage users and billing data from the UI:
- manually fix broken subscriptions / credits if Stripe webhook didn’t work
- edit user profile & plan
- add or remove load credits
- block / unblock users
- keep an audit log of all admin actions
Do NOT break or simplify any existing flows. Only ADD small, localized changes.

IMPORTANT CONSTRAINTS
- Do not remove or rename existing models, routes, or Stripe logic.
- Re-use the existing admin auth (ADMIN_EMAILS, ADMIN_PASSWORD, JWT_SECRET).
- Keep all existing behaviour of billing (/api/billing/*), loads, and Stripe webhooks as is.
- All new admin features must be guarded by the existing admin JWT middleware.
- Keep styling consistent with the current dark neon UI.

--------------------------------------------------
1. BACKEND: ADMIN AUTH & MIDDLEWARE (VERIFY JWT)
--------------------------------------------------
1. Locate the existing admin login endpoint (it is currently used by /app/admin/login). 
   - It already issues a JWT for admins. 
   - Reuse the same secret (JWT_SECRET) and payload structure.

2. Create/reuse a small Express middleware function, e.g. in `src/middleware/adminAuth.ts` (or similar) that:
   - Reads the `Authorization: Bearer <token>` header from the request.
   - Verifies the JWT using JWT_SECRET.
   - Checks that the email in the token is included in ADMIN_EMAILS.
   - On success attaches `req.admin = { email }`.
   - On failure returns 401 JSON `{ error: 'Unauthorized' }`.

3. Apply this middleware to ALL new `/api/admin/*` routes created below.

--------------------------------------------------
2. BACKEND: ADMIN USER MANAGEMENT ROUTES
--------------------------------------------------
Goal: allow the admin UI to:
- list users (already exists – keep as is)
- edit a user
- adjust credits / loads
- block / unblock users

1. Locate the User / billing models (Prisma or ORM):
   - There is already a User model used for broker accounts.
   - There is already a billing summary model that powers `/api/billing/summary` (it contains plan, loadsUsed, includedLoads, creditBalance or similar). 
   - DO NOT rename these models. Reuse them.

2. Create a new route file for admin user actions, for example:
   - `src/routes/adminUsers.ts` OR extend an existing `admin` router.
   - Mount it under `/api/admin/users`.

3. Implement the following endpoints (all behind adminAuth middleware):

   a) `GET /api/admin/users`
      - Return the same data currently used for the Users tab:
        `{ id, email, name, plan, loadsUsed, includedLoads, creditBalance, blocked }`.
      - If there is no `blocked` flag on the user, add a boolean field on the User model, e.g. `isBlocked` (default false) via a minimal migration, and map it to `blocked` in the API response.

   b) `PATCH /api/admin/users/:userId`
      - Body can contain any of:
        - `name?: string`
        - `plan?: 'FREE' | 'PRO'`
        - `isBlocked?: boolean`
      - Update the User and/or billing summary accordingly:
        - Changing plan:
          - Update the billing summary plan field.
          - Do NOT touch Stripe subscriptions here; this endpoint is only for emergency manual fix.
      - Return the updated user summary.

   c) `POST /api/admin/users/:userId/credits`
      - Body: `{ deltaCredits: number, reason?: string }`
      - Use the existing billing summary record:
        - Increase `creditBalance` by `deltaCredits` (delta can be negative to remove credits).
      - Save to DB and return the new billing summary.
      - Also create an audit log entry (see section 4).

   d) `POST /api/admin/users/:userId/loads/reset`
      - Body: `{ reason?: string }`
      - Set `loadsUsed` for the current billing cycle to 0 in the billing summary table.
      - Do not change includedLoads or creditBalance.
      - Also create an audit log entry.

4. If there is any existing business logic for computing billing summary (used by `/api/billing/summary`), extract it into a helper and reuse it when returning admin user summaries so everything stays consistent.

--------------------------------------------------
3. BACKEND: BLOCKING LOGIC (EMAIL / IP / PHONE)
--------------------------------------------------
1. For minimal implementation, start with a simple flag on the User record:
   - `isBlocked Boolean @default(false)`.
   - If such field already exists, reuse it.

2. Create an optional table for blocking metadata only if it does not exist yet, e.g.:

   model BlockedEntity {
     id        String   @id @default(cuid())
     userId    String   @unique
     email     String
     phone     String?
     ip        String?
     reason    String?
     createdAt DateTime @default(now())
   }

   - Connect it to the User via `userId`.
   - This table is only for admin reference; it should not affect normal auth logic unless the code already uses `isBlocked`.

3. When the admin sets `isBlocked` to true via the PATCH endpoint:
   - Update User.isBlocked.
   - Upsert a BlockedEntity row with email / known phone / last known IP if you can get it from the existing models.
   - Add an audit log entry.

4. When the admin unblocks a user:
   - Set `isBlocked` to false.
   - Optionally keep BlockedEntity but mark it as historical (e.g. add `active` flag or leave as is, it’s fine).

5. Ensure that wherever users sign in or create loads there is already (or add) a simple check:
   - If `user.isBlocked === true`, reject the action with an error like `{ error: 'Account blocked by admin' }`.
   - Do NOT add heavy logic; just a simple guard around existing login / create-load endpoints.

--------------------------------------------------
4. BACKEND: AUDIT LOGS
--------------------------------------------------
1. Check if there is already an AuditLog model. If not, create a new minimal Prisma model:

   model AuditLog {
     id        String   @id @default(cuid())
     createdAt DateTime @default(now())
     adminEmail String
     action    String   // e.g. 'USER_UPDATE', 'CREDITS_ADJUST', 'LOADS_RESET', 'USER_BLOCK', 'USER_UNBLOCK', 'PROMO_CREATE'
     details   Json
   }

2. Create API routes for audit logs:

   - `GET /api/admin/audit`
     - Returns a paginated list of logs sorted by createdAt DESC.
   - All admin-mutating endpoints from sections 2 and 3 must create an AuditLog record with:
     - `adminEmail` from `req.admin.email`
     - `action` string describing operation
     - `details` JSON with important info (userId, deltaCredits, newPlan, reason, etc.).

--------------------------------------------------
5. FRONTEND: ADMIN USERS TAB – ACTIONS UI
--------------------------------------------------
1. Open the React/Next component for `/app/admin` and, specifically, the Users tab.
   - Currently it only renders a table of users and is read-only.
   - Do not change the overall layout or styling.

2. Add a new “Actions” column (if not already present) that shows small buttons for each row:
   - “Edit”
   - “Credits”
   - “Block” or “Unblock” depending on `user.blocked`.
   - Keep buttons compact and consistent with existing button styles.

3. Implement modals/drawers:

   a) Edit user modal:
      - Fields: Name (text), Plan (FREE / PRO select), Blocked (checkbox).
      - On Save:
        - Send `PATCH /api/admin/users/:id` with changed fields only.
        - On success, refresh the users list and show a small success toast.
      - Close modal on success.

   b) Adjust credits modal:
      - Field: `deltaCredits` (number; can be negative).
      - Optional `reason` text.
      - On Confirm:
        - Call `POST /api/admin/users/:id/credits`.
        - On success, update the row and close modal.

   c) Quick Block / Unblock button:
      - When clicked, immediately calls `PATCH /api/admin/users/:id` with `isBlocked: true` or `false`.
      - Ask for a small confirmation dialog and an optional reason string if blocking.

4. Make sure all admin requests send the admin JWT from local storage / cookie:
   - Use the same mechanism already used to load data for the existing admin panel tabs (reuse existing fetch helper).

--------------------------------------------------
6. FRONTEND: AUDIT LOGS TAB
--------------------------------------------------
1. Update the Audit Logs tab component so that it uses the new API endpoint:
   - Fetch from `GET /api/admin/audit`.
   - Display columns: Time, Admin, Action, Details.
   - Render details as a compact JSON string or a human-friendly text.

2. Implement a simple “Refresh” icon/button to reload logs.

--------------------------------------------------
7. SAFETY CHECKS & TESTS
--------------------------------------------------
1. Run the dev server and verify:
   - Normal broker flows still work: sign up, create load, billing page, Stripe checkout, buying extra credits.
   - Admin login still works at `/app/admin/login`.

2. As admin:
   - Open Users tab and confirm users list loads.
   - Use “Edit” to change a user’s name and plan; confirm it updates and is reflected in billing summary.
   - Use “Credits” to add e.g. +10 credits; check billing summary for that user and that credits are applied.
   - Block a user and then try to login / create a load as that user – it should be rejected.
   - Unblock and verify user can work again.
   - Open Audit Logs tab and confirm all actions appear correctly.

3. Keep code changes small and localized. Do NOT refactor unrelated parts of the system.