
```markdown
# Task: Add PDF Parsing and Geofencing Features (WITHOUT Breaking Existing Code)

## ⚠️ CRITICAL: DO NOT MODIFY EXISTING FUNCTIONALITY
- Do NOT change existing routes, models, or API endpoints
- Do NOT remove any existing code
- ONLY ADD new features alongside existing code
- Keep all existing load creation logic working as-is

## Project Analysis Required FIRST

Before making ANY changes:

1. **Identify the database ORM:**
   - Check `backend/models/` or `backend/prisma/` or `backend/database/`
   - Are we using Prisma, Sequelize, Mongoose, or TypeORM?
   - Find the existing Load/Shipment model

2. **Identify existing routes:**
   - Check `backend/routes/` or `backend/api/`
   - Find existing load creation endpoint
   - Note the current request/response structure

3. **Check frontend load creation:**
   - Find the component that creates loads
   - Understand current form structure
   - Identify where to add PDF upload

## Feature 1: PDF Parsing with Claude API

### Step 1: Add Dependencies (Safe - No Breaking Changes)

```bash
cd backend
npm install @anthropic-ai/sdk multer
```

### Step 2: Create NEW Service File (No Modifications to Existing Code)

Create **NEW** file: `backend/services/pdfParser.js`

```javascript
const Anthropic = require('@anthropic-ai/sdk');
const fs = require('fs').promises;

const anthropic = new Anthropic({
  apiKey: process.env.CLAUDE_API_KEY
});

/**
 * Parse PDF rate confirmation using Claude API
 * Returns structured data matching our Load model
 */
async function parsePdfDocument(pdfFilePath) {
  try {
    // Read PDF file as base64
    const pdfBuffer = await fs.readFile(pdfFilePath);
    const base64Pdf = pdfBuffer.toString('base64');
    
    const message = await anthropic.messages.create({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 2000,
      messages: [{
        role: 'user',
        content: [
          {
            type: 'document',
            source: {
              type: 'base64',
              media_type: 'application/pdf',
              data: base64Pdf
            }
          },
          {
            type: 'text',
            text: `Extract freight/logistics information from this PDF and return ONLY valid JSON (no markdown, no explanation):

{
  "pickupAddress": "",
  "pickupCity": "",
  "pickupState": "",
  "pickupZip": "",
  "deliveryAddress": "",
  "deliveryCity": "",
  "deliveryState": "",
  "deliveryZip": "",
  "pickupDate": "",
  "deliveryDate": "",
  "rate": "",
  "commodity": "",
  "weight": "",
  "notes": "",
  "shipperName": "",
  "shipperPhone": "",
  "receiverName": "",
  "receiverPhone": ""
}`
          }
        ]
      }
    });
    
    const textContent = message.content.find(c => c.type === 'text')?.text || '{}';
    const parsed = JSON.parse(textContent.trim());
    
    // Clean up uploaded file
    await fs.unlink(pdfFilePath).catch(() => {});
    
    return {
      success: true,
      data: parsed
    };
    
  } catch (error) {
    console.error('PDF parsing error:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

module.exports = { parsePdfDocument };
```

### Step 3: Create NEW Route (Separate from Existing Routes)

Create **NEW** file: `backend/routes/pdfRoutes.js`

```javascript
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const { parsePdfDocument } = require('../services/pdfParser');

// Configure multer for PDF uploads
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/pdfs/') // Make sure this directory exists
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname)
  }
});

const upload = multer({
  storage: storage,
  fileFilter: (req, file, cb) => {
    if (path.extname(file.originalname).toLowerCase() === '.pdf') {
      cb(null, true);
    } else {
      cb(new Error('Only PDF files allowed'));
    }
  },
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB limit
});

// NEW endpoint - does NOT interfere with existing endpoints
router.post('/parse-rate-confirmation', upload.single('pdf'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ 
        success: false, 
        error: 'No PDF file uploaded' 
      });
    }

    const result = await parsePdfDocument(req.file.path);
    
    res.json(result);
    
  } catch (error) {
    console.error('Route error:', error);
    res.status(500).json({ 
      success: false, 
      error: error.message 
    });
  }
});

module.exports = router;
```

### Step 4: Register NEW Route (Add to Existing app.js/server.js)

**Find your main server file** (app.js or server.js in backend/) and **ADD** this line:

```javascript
// ADD this import at the top with other route imports
const pdfRoutes = require('./routes/pdfRoutes');

// ADD this line with other route registrations
app.use('/api/pdf', pdfRoutes);
```

### Step 5: Update Frontend (Add PDF Upload Option)

**Find existing load creation component** and **ADD** PDF upload option:

```javascript
// ADD to your existing load creation form component
const [pdfFile, setPdfFile] = useState(null);
const [parsing, setParsing] = useState(false);

// ADD this function
const handlePdfUpload = async (event) => {
  const file = event.target.files[0];
  if (!file) return;
  
  setParsing(true);
  const formData = new FormData();
  formData.append('pdf', file);
  
  try {
    const response = await fetch('/api/pdf/parse-rate-confirmation', {
      method: 'POST',
      body: formData
    });
    
    const result = await response.json();
    
    if (result.success) {
      // Pre-fill existing form fields with parsed data
      setFormData(prev => ({
        ...prev,
        ...result.data
      }));
      alert('PDF parsed successfully! Please review the data.');
    } else {
      alert('Failed to parse PDF: ' + result.error);
    }
  } catch (error) {
    alert('Error uploading PDF: ' + error.message);
  } finally {
    setParsing(false);
  }
};

// ADD to your existing form JSX (before or after existing fields):
<div className="pdf-upload-section">
  <label>Upload Rate Confirmation PDF (Optional):</label>
  <input 
    type="file" 
    accept=".pdf"
    onChange={handlePdfUpload}
    disabled={parsing}
  />
  {parsing && <p>Parsing PDF...</p>}
</div>
```

### Step 6: Environment Variables

**ADD** to `.env` file (create if doesn’t exist):

```
CLAUDE_API_KEY=your_api_key_here
```

### Step 7: Create Upload Directory

```bash
mkdir -p backend/uploads/pdfs
```

## Feature 2: Geofencing Auto-Detection

### Step 1: Analyze Existing Load Model FIRST

**BEFORE making changes**, check:

- What ORM are you using? (Prisma/Sequelize/Mongoose)
- What fields does Load model already have?
- Is there a `status` field? What are current status values?

### Step 2: Extend Load Model (ADD fields, don’t remove)

**Example for Mongoose:**

```javascript
// In existing Load model file, ADD these fields to schema:
pickupLocation: {
  lat: { type: Number },
  lon: { type: Number },
  radius: { type: Number, default: 500 } // meters
},
deliveryLocation: {
  lat: { type: Number },
  lon: { type: Number },
  radius: { type: Number, default: 500 }
},
currentDriverLocation: {
  lat: { type: Number },
  lon: { type: Number },
  lastUpdated: { type: Date }
},
autoTracking: {
  pickupArrived: { type: Boolean, default: false },
  pickupArrivedAt: { type: Date },
  pickupDeparted: { type: Boolean, default: false },
  pickupDepartedAt: { type: Date },
  deliveryArrived: { type: Boolean, default: false },
  deliveryArrivedAt: { type: Date },
  deliveryDeparted: { type: Boolean, default: false },
  deliveryDepartedAt: { type: Date }
},
geofenceLog: [{
  location: String, // 'pickup' or 'delivery'
  event: String, // 'entered' or 'exited'
  timestamp: Date,
  auto: Boolean
}]
```

**Example for Prisma:**

```prisma
// Add to existing Load model in schema.prisma:
model Load {
  // ... existing fields ...
  
  pickupLat        Float?
  pickupLon        Float?
  pickupRadius     Int     @default(500)
  deliveryLat      Float?
  deliveryLon      Float?
  deliveryRadius   Int     @default(500)
  
  currentLat       Float?
  currentLon       Float?
  locationUpdated  DateTime?
  
  pickupArrived    Boolean @default(false)
  pickupArrivedAt  DateTime?
  pickupDeparted   Boolean @default(false)
  pickupDepartedAt DateTime?
  
  deliveryArrived    Boolean @default(false)
  deliveryArrivedAt  DateTime?
  deliveryDeparted   Boolean @default(false)
  deliveryDepartedAt DateTime?
  
  geofenceLogs     GeofenceLog[]
}

model GeofenceLog {
  id        Int      @id @default(autoincrement())
  loadId    Int
  load      Load     @relation(fields: [loadId], references: [id])
  location  String
  event     String
  timestamp DateTime @default(now())
  auto      Boolean  @default(false)
}
```

### Step 3: Install Dependencies

```bash
cd backend
npm install geolib node-cron
```

### Step 4: Create Geofencing Service

Create **NEW** file: `backend/services/geofencing.js`

```javascript
const { getDistance } = require('geolib');

/**
 * Check if truck is within geofence radius
 */
function isWithinGeofence(truckLat, truckLon, locationLat, locationLon, radiusMeters = 500) {
  if (!truckLat || !truckLon || !locationLat || !locationLon) {
    return false;
  }
  
  const distance = getDistance(
    { latitude: truckLat, longitude: truckLon },
    { latitude: locationLat, longitude: locationLon }
  );
  
  return distance <= radiusMeters;
}

/**
 * Determine what auto-actions should be taken
 */
function checkGeofenceStatus(load) {
  const actions = {
    shouldMarkPickupArrival: false,
    shouldMarkPickupDeparture: false,
    shouldMarkDeliveryArrival: false,
    shouldMarkDeliveryDeparture: false
  };
  
  if (!load.currentDriverLocation || !load.currentDriverLocation.lat) {
    return actions; // No location data
  }
  
  const { lat: currentLat, lon: currentLon } = load.currentDriverLocation;
  
  // Check pickup geofence
  const inPickupZone = isWithinGeofence(
    currentLat, currentLon,
    load.pickupLocation?.lat, load.pickupLocation?.lon,
    load.pickupLocation?.radius
  );
  
  // Check delivery geofence
  const inDeliveryZone = isWithinGeofence(
    currentLat, currentLon,
    load.deliveryLocation?.lat, load.deliveryLocation?.lon,
    load.deliveryLocation?.radius
  );
  
  // Logic: if in zone for 10+ minutes → mark arrival
  // This requires checking geofence log for entry time
  const pickupEntry = load.geofenceLog?.find(
    log => log.location === 'pickup' && log.event === 'entered' && !hasExited(load, 'pickup', log.timestamp)
  );
  
  if (inPickupZone && pickupEntry && !load.autoTracking?.pickupArrived) {
    const minutesInZone = (Date.now() - new Date(pickupEntry.timestamp)) / 60000;
    if (minutesInZone >= 10) {
      actions.shouldMarkPickupArrival = true;
    }
  }
  
  // If was in zone, now outside, and arrived but not departed
  if (!inPickupZone && load.autoTracking?.pickupArrived && !load.autoTracking?.pickupDeparted) {
    actions.shouldMarkPickupDeparture = true;
  }
  
  // Same logic for delivery
  const deliveryEntry = load.geofenceLog?.find(
    log => log.location === 'delivery' && log.event === 'entered' && !hasExited(load, 'delivery', log.timestamp)
  );
  
  if (inDeliveryZone && deliveryEntry && !load.autoTracking?.deliveryArrived) {
    const minutesInZone = (Date.now() - new Date(deliveryEntry.timestamp)) / 60000;
    if (minutesInZone >= 10) {
      actions.shouldMarkDeliveryArrival = true;
    }
  }
  
  if (!inDeliveryZone && load.autoTracking?.deliveryArrived && !load.autoTracking?.deliveryDeparted) {
    actions.shouldMarkDeliveryDeparture = true;
  }
  
  return { actions, inPickupZone, inDeliveryZone };
}

function hasExited(load, location, entryTimestamp) {
  return load.geofenceLog?.some(
    log => log.location === location && 
           log.event === 'exited' && 
           new Date(log.timestamp) > new Date(entryTimestamp)
  );
}

module.exports = { isWithinGeofence, checkGeofenceStatus };
```

### Step 5: Create Background Job

Create **NEW** file: `backend/jobs/geofenceMonitor.js`

```javascript
const cron = require('node-cron');
const { checkGeofenceStatus } = require('../services/geofencing');
// Import your Load model here based on your ORM

/**
 * Runs every minute to check active loads
 */
function startGeofenceMonitoring(LoadModel) {
  cron.schedule('* * * * *', async () => {
    try {
      // Find active loads with location data
      const activeLoads = await LoadModel.find({
        status: { $in: ['active', 'in_transit', 'assigned'] }, // Adjust based on your status values
        'currentDriverLocation.lat': { $exists: true, $ne: null }
      });
      
      for (const load of activeLoads) {
        const { actions, inPickupZone, inDeliveryZone } = checkGeofenceStatus(load);
        
        // Log zone entry/exit
        await logGeofenceEvent(load, 'pickup', inPickupZone);
        await logGeofenceEvent(load, 'delivery', inDeliveryZone);
        
        // Auto-mark arrivals/departures
        if (actions.shouldMarkPickupArrival) {
          load.autoTracking.pickupArrived = true;
          load.autoTracking.pickupArrivedAt = new Date();
          console.log(`Auto-marked pickup arrival for load ${load._id}`);
        }
        
        if (actions.shouldMarkPickupDeparture) {
          load.autoTracking.pickupDeparted = true;
          load.autoTracking.pickupDepartedAt = new Date();
          console.log(`Auto-marked pickup departure for load ${load._id}`);
        }
        
        if (actions.shouldMarkDeliveryArrival) {
          load.autoTracking.deliveryArrived = true;
          load.autoTracking.deliveryArrivedAt = new Date();
          console.log(`Auto-marked delivery arrival for load ${load._id}`);
        }
        
        if (actions.shouldMarkDeliveryDeparture) {
          load.autoTracking.deliveryDeparted = true;
          load.autoTracking.deliveryDepartedAt = new Date();
          load.status = 'delivered'; // Update status if this is final step
          console.log(`Auto-marked delivery departure for load ${load._id}`);
        }
        
        await load.save();
      }
      
    } catch (error) {
      console.error('Geofence monitoring error:', error);
    }
  });
  
  console.log('Geofence monitoring started - running every minute');
}

async function logGeofenceEvent(load, location, isInZone) {
  const lastLog = load.geofenceLog?.[load.geofenceLog.length - 1];
  const lastEvent = lastLog?.location === location ? lastLog.event : null;
  
  // Log entry if entered zone
  if (isInZone && lastEvent !== 'entered') {
    load.geofenceLog.push({
      location,
      event: 'entered',
      timestamp: new Date(),
      auto: true
    });
  }
  
  // Log exit if left zone
  if (!isInZone && lastEvent === 'entered') {
    load.geofenceLog.push({
      location,
      event: 'exited',
      timestamp: new Date(),
      auto: true
    });
  }
}

module.exports = { startGeofenceMonitoring };
```

### Step 6: Start Monitoring in Server

**In your main server file**, ADD:

```javascript
const { startGeofenceMonitoring } = require('./jobs/geofenceMonitor');
const Load = require('./models/Load'); // Your Load model

// ADD after server starts:
startGeofenceMonitoring(Load);
```

### Step 7: Create Location Update Endpoint

Create **NEW** file: `backend/routes/locationRoutes.js`

```javascript
const express = require('express');
const router = express.Router();
// Import your Load model

router.post('/update', async (req, res) => {
  try {
    const { loadId, latitude, longitude } = req.body;
    
    await Load.findByIdAndUpdate(loadId, {
      currentDriverLocation: {
        lat: latitude,
        lon: longitude,
        lastUpdated: new Date()
      }
    });
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ success: false, error: error.message });
  }
});

module.exports = router;
```

Register route in main server file:

```javascript
const locationRoutes = require('./routes/locationRoutes');
app.use('/api/location', locationRoutes);
```

### Step 8: Frontend - Driver Location Tracking

**In driver app component**, ADD location tracking:

```javascript
useEffect(() => {
  let locationInterval;
  
  if (activeLoadId) {
    // Send location every 2 minutes
    locationInterval = setInterval(() => {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          async (position) => {
            await fetch('/api/location/update', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                loadId: activeLoadId,
                latitude: position.coords.latitude,
                longitude: position.coords.longitude
              })
            });
          },
          (error) => console.error('Location error:', error)
        );
      }
    }, 120000); // 2 minutes
  }
  
  return () => clearInterval(locationInterval);
}, [activeLoadId]);
```

## Testing Plan

1. **Test PDF Parsing:**

- Upload sample PDF → verify data extraction
- Create load manually (without PDF) → ensure still works
- Upload PDF → verify form pre-fills

1. **Test Geofencing:**

- Simulate driver location updates
- Check logs to see zone entry/exit
- Wait 10 minutes in zone → verify auto-arrival
- Leave zone → verify auto-departure

## Safety Checklist

- [ ] No existing routes modified
- [ ] No existing models removed/broken
- [ ] All new code in NEW files
- [ ] Manual load creation still works
- [ ] Manual arrive/departure buttons still work
- [ ] Database migrations run successfully
- [ ] Environment variables documented

Please implement following this safe, incremental approach. Test each feature independently before moving to the next.
